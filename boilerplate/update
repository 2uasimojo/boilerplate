#!/usr/bin/env bash

# WARNING: THIS FILE IS MANAGED IN THE 'boilerplate' REPO AND COPIED TO OTHER REPOSITORIES.
# ONLY EDIT THIS FILE FROM WITHIN THE 'boilerplate' REPOSITORY.
#
# TO OPT OUT OF UPDATES, SEE THE README.

# This script updates itself, and then re-execs itself if it has
# changed. This is in case updates to conventions rely on updates to this
# script.

set -e
if [ "$BOILERPLATE_SET_X" ]; then
    set -x
fi

# The directory in which this script lives is the CONVENTION_ROOT. Export
# this for individual `update` scripts.
export CONVENTION_ROOT="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null && pwd )"

# We're initially invoked with no arguments. The branch below clones the
# boilerplate repo at the latest level into a temporary directory and copies in
# the update script (this script) and utilities back into the consuming repo.
# Then it re-execs this script with the temporary directory as a CLI argument.
if [[ -z "$1" ]]; then
  # Allow dirty checkout only when modifying the config (e.g. subscribing to a
  # new convention).
  # NOTE: It would be lovely to do this via the `make` target by adding `isclean`
  # as a dep. But:
  # a) For initial bootstrap we would have a chicken/egg problem, unless we
  #    included `isclean` in the Makefile content to be copy-pasted in, which is
  #    kind of icky.
  # b) We want to allow an exception for update.cfg as noted above.
  if [[ -n "$(git status --porcelain | grep -F -v ' boilerplate/update.cfg')" ]]; then
    cat <<EOF
  Local git checkout is not clean. Commit your changes and try again (even if
  this is your initial bootstrap of boilerplate).
EOF
    exit 2
  fi

  if [ -z "$BOILERPLATE_GIT_REPO" ]; then
    BOILERPLATE_GIT_REPO=git@github.com:openshift/boilerplate.git
  fi
  if [ -z "$BOILERPLATE_GIT_CLONE" ]; then
    BOILERPLATE_GIT_CLONE="git clone $BOILERPLATE_GIT_REPO"
  fi
  OUT="$(mktemp -d)"
  $BOILERPLATE_GIT_CLONE "${OUT}"
  echo "Updating the update script."
  rsync -a "${OUT}/boilerplate/update" "$0"
  echo "Copying utilities"
  rsync -a -r --delete ${OUT}/boilerplate/_* $CONVENTION_ROOT
  echo "Reinvoking..."
  echo ""
  exec "$0" "$OUT"
  # unreached
fi

OUT=$1
# Let's make sure this was really a re-exec and not some other
# weirdness.
if ! [[ -d "$OUT" ]] || ! diff -q "$0" "$OUT/boilerplate/update"; then
  echo "Something went wrong! I was invoked with '$OUT'!"
  exit 2
fi
TO_COMMIT=$(cd ${OUT} && git rev-parse HEAD)

trap "rm -fr $OUT" EXIT

# Allow this to be overridden by the environment, in case some bizarre
# repo doesn't have an `origin` remote.
if [ -z "$REPO_NAME" ]; then
  # This is a tad ambitious, but it should usually work.
  export REPO_NAME=$(git config --get remote.origin.url | sed 's,.*/,,; s/\.git$//')
  # If that still didn't work, warn (but proceed)
  if [ -z "$REPO_NAME" ]; then
    echo 'Failed to discover repository name! $REPO_NAME not set!'
  fi
fi

export REPO_ROOT=$(git rev-parse --show-toplevel)

CONFIG_FILE="${CONVENTION_ROOT}/update.cfg"
README="https://github.com/openshift/boilerplate/blob/master/README.md"

if [ ! -f "$CONFIG_FILE" ]; then
  echo "$CONFIG_FILE not found."
  echo "This file is required in order to select which features to include."
  echo "See $README for more details."
  exit 1
fi

# Prepare the "nexus makefile include".
NEXUS_MK="${CONVENTION_ROOT}/generated-includes.mk"
cat <<EOF>"${NEXUS_MK}"
# THIS FILE IS GENERATED BY BOILERPLATE. DO NOT EDIT.
# This file automatically includes any *.mk files in your subscribed
# conventions. Please ensure your base Makefile includes only this file.
EOF

conventions=
while read directory junk; do
  # Skip comment lines (which can have leading whitespace)
  if [[ "$directory" == '#'* ]]; then
    continue
  fi
  # Skip blank or whitespace-only lines
  if [[ "$directory" == "" ]]; then
    continue
  fi
  # Lines like
  #    valid/path  other_junk
  # are not acceptable, unless `other_junk` is a comment
  if [[ "$junk" != "" ]] && [[ "$junk" != '#'* ]]; then
    echo "Invalid config! Only one directory is allowed per line. Found '$junk'"
    exit 1
  fi

  dir_path="${OUT}/boilerplate/${directory}"
  # Make sure the directory exists
  if ! [[ -d "$dir_path" ]]; then
    echo "Invalid convention directory: '$directory'"
    exit 1
  fi

  # Okay, a valid convention. Save as a URL for the commit message.
  conventions="$conventions
- https://github.com/openshift/boilerplate/tree/$TO_COMMIT/boilerplate/$convention"

  echo "***********************************************************************************"
  echo "$directory is configured in update.cfg."
  echo "-----------------------------------------------------------------------------------"
  echo "syncing files from source."
  if [ -f "${dir_path}/update" ]; then
    # Always run the *new* update script
    mkdir -p "${CONVENTION_ROOT}/${directory}"
    rsync -a "${dir_path}/update" "${CONVENTION_ROOT}/${directory}"
    echo "executing ${CONVENTION_ROOT}/${directory}/update PRE"
    "${CONVENTION_ROOT}/${directory}/update" PRE
  fi
  rm -rf "${CONVENTION_ROOT}/${directory}"
  mkdir -p $(dirname "${CONVENTION_ROOT}/${directory}")
  rsync -a -r --delete "$dir_path" $(dirname "${CONVENTION_ROOT}/${directory}")
  if [ -f "${CONVENTION_ROOT}/${directory}/update" ]; then
    echo "executing ${CONVENTION_ROOT}/${directory}/update POST"
    "${CONVENTION_ROOT}/${directory}/update" POST
  fi
  echo "adding makefile includes."
  for inc in $(find "${CONVENTION_ROOT}/${directory}" -type f -name '*.mk' | sort); do
    echo "include ${inc#$REPO_ROOT/}" >> "${NEXUS_MK}"
  done
  echo "***********************************************************************************"
  echo ""
done < "$CONFIG_FILE"

# If all that went well, lay down the last-boilerplate-commit file,
# which allows freeze-check to work.

# Last Boilerplate Commit File
LBCF=${CONVENTION_ROOT}/_data/last-boilerplate-commit
ACTION=bootstrap
if [[ -f $LBCF ]]; then
  FROM_COMMIT=$(cat $LBCF)
  if [[ -n "$FROM_COMMIT" ]]; then
    # If the commit hash didn't change, this could have just been an update to
    # subscribe to a new convention. But if not...
    if [[ "$FROM_COMMIT" == "$TO_COMMIT" ]]; then
      if [[ -z "$(git status --porcelain)" ]]; then
        echo "This update was a no-op! Did you forget to subscribe to a convention?"
        exit 0
      fi
      ACTION=subscribe
    else
      ACTION=update
      COMMITISH=$(cat $LBCF)...$TO_COMMIT
    fi
  else
    # The file existed, but was empty. This is weird... but okay.
    echo "WARNING: Empty last-boilerplate-commit file!"
  fi
fi

# Possibly redundant, but harmless
mkdir -p ${CONVENTION_ROOT}/_data
echo "Registering commit hash..."
echo ${TO_COMMIT} > $LBCF

if [[ -z "$conventions" ]]; then
  conventios="No conventions processed."
else
  conventions="Processed conventions:
$conventions"
fi

# Granny switch to avoid creating the automated commit
if [[ -n "$BOILERPLATE_UPDATE_NO_COMMIT" ]]; then
  echo "Done."
  exit 0
fi

echo "Creating a commit..."
BRANCH=boilerplate-$ACTION-$TO_COMMIT
# TODO: It's possible (though slightly difficult) to generate the same
# branch name for different commits. This works around it, but we should
# come up with a better naming system.
if git branch | grep $BRANCH; then
  BRANCH=$BRANCH-$$-$PPID
fi
# TODO: Should we make sure we're synced with upstream? For now leave that the
# responsibility of the user.
git checkout -b $BRANCH
git add -A

# Is this the very first update?
case $ACTION in

bootstrap)

  git commit -F - <<EOF
Boilerplate: bootstrap at $TO_COMMIT

https://github.com/openshift/boilerplate/tree/$TO_COMMIT/

$conventions
EOF
  ;;

update)

  git commit -F - <<EOF
Boilerplate: update to $TO_COMMIT

$conventions

https://github.com/openshift/boilerplate/compare/$COMMITISH

---
\`\`\`
$(cd $OUT; git log --no-merges --pretty=format:'commit: %H%nauthor: %an%n%s%n%n%b%n%n' $COMMITISH)
\`\`\`
EOF
  ;;

subscribe)

  git commit -F - <<EOF
Boilerplate: subscribe

$conventions
EOF
  ;;

esac

cat <<EOF

***********************************************************************************
All done.

ACTION REQUIRED:
- Pay attention to any instructions in the output above.
- (Re)read the README for your subscribed convention(s).
- See what changed in this update by running: git show
- Make any changes necessary to accommodate the above. (But don't touch the
  files owned by boilerplate!)
- If changes were necessary, add them to this branch, preferably in a separate
  commit.
- Push the branch to create a pull request: git push origin $BRANCH
EOF
