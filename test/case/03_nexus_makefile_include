#!/bin/bash -e

sub_hdr() {
    cat <<EOF

>>>>
>>>> $@
>>>>

EOF
}

# Use this to silence "Entering/Leaving directory" messages when needing
# to compare output sanely
make_q='make --no-print-directory'

REPO_ROOT=$(git rev-parse --show-toplevel)

source $REPO_ROOT/test/lib.sh

# A temp directory for expected output/files
expected=$(mktemp -d)
add_cleanup $expected
cat <<EOF>$expected/nmi_header
# THIS FILE IS GENERATED BY BOILERPLATE. DO NOT EDIT.
# This file automatically includes any *.mk files in your subscribed
# conventions. Please ensure your base Makefile includes only this file.
EOF
exp_nmi=$expected/nmi

repo=$(empty_repo)
add_cleanup $repo

bootstrap_repo $repo

cd $repo

# TODO: test REPO_NAME detection by setting an appropriately-formatted
# git remote
export REPO_NAME=${0##*/}

sub_hdr "Baseline"
make update_boilerplate
check_update $repo

sub_hdr "Include with no conventions"
# NOTE: We can't actually do this until we've updated at least once, to
# bootstrap the nexus Makefile include into our target repo. Is that a
# problem? The only way around it would be to touch that file along with
# the update.cfg when bootstrapping. But we'd like to minimize the
# number of things that need to be bootstrapped in that way.
ensure_nexus_makefile_include $repo
check_update $repo
# Nexus Makefile include should have only the header
diff $expected/nmi_header $NEXUS_MK

sub_hdr "Convention with no includes"
add_convention $repo test/nexus_makefile_include/no_includes
make update_boilerplate
check_update $repo
# Nexus Makefile include should have only the header
diff $expected/nmi_header $NEXUS_MK

# Clear the config
bootstrap_repo $repo

sub_hdr "Convention with one include"
convention=test/nexus_makefile_include/one_include
add_convention $repo $convention
make update_boilerplate
check_update $repo
cat $expected/nmi_header > $exp_nmi
echo "include boilerplate/$convention/one.mk" >> $exp_nmi
diff $exp_nmi $NEXUS_MK
# Our base Makefile doesn't include the nmi yet
if make one_one 2>/dev/null; then
    echo "Didn't expect the 'one_one' make target to resolve yet."
    exit 1
fi
# Now include it and the target should work
ensure_nexus_makefile_include $repo
echo "one_one" > $expected/expected_out
$make_q one_one > $expected/actual_out
diff $expected/expected_out $expected/actual_out

# Reset Makefile and config
bootstrap_repo $repo

sub_hdr "Convention with multiple includes"
convention=test/nexus_makefile_include/multiple_includes
add_convention $repo $convention
make update_boilerplate
check_update $repo
cat $expected/nmi_header > $exp_nmi
# NOTE: These are added in lexical sort order!
cat <<EOF >> $exp_nmi
include boilerplate/$convention/one.mk
include boilerplate/$convention/three.mk
include boilerplate/$convention/two.mk
EOF
diff $exp_nmi $NEXUS_MK
ensure_nexus_makefile_include $repo
echo "mult_one" > $expected/expected_out
$make_q mult_one > $expected/actual_out
diff $expected/expected_out $expected/actual_out

# Reset Makefile and config
bootstrap_repo $repo

sub_hdr "Multiple conventions"
for c in no_includes one_include multiple_includes; do
    add_convention $repo test/nexus_makefile_include/$c
done
make update_boilerplate
check_update $repo
cat $expected/nmi_header > $exp_nmi
# NOTE: The *convention* order is honored, even though the *includes*
# are sorted within a convention.
cat <<EOF >> $exp_nmi
include boilerplate/test/nexus_makefile_include/one_include/one.mk
include boilerplate/test/nexus_makefile_include/multiple_includes/one.mk
include boilerplate/test/nexus_makefile_include/multiple_includes/three.mk
include boilerplate/test/nexus_makefile_include/multiple_includes/two.mk
EOF
diff $exp_nmi $NEXUS_MK
ensure_nexus_makefile_include $repo
# Let's add a new target to our Makefile that requires all of the above
cat <<EOF >>Makefile

.PHONY: foo
foo: mult_two one_one mult_three mult_one
EOF
cat <<EOF > $expected/expected_out
mult_two
one_one
mult_three
mult_one
EOF
$make_q foo > $expected/actual_out
diff $expected/expected_out $expected/actual_out
